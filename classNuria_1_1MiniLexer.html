<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>NuriaProject Framework: Nuria::MiniLexer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NuriaProject Framework
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">The NuriaProject Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Nuria</b></li><li class="navelem"><a class="el" href="classNuria_1_1MiniLexer.html">MiniLexer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classNuria_1_1MiniLexer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Nuria::MiniLexer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple lexer. You can use this class if you want to parse some data based on regular expressions. It is not really smart, as it is meant to be used for simple tasks. NQL uses it for example to parse queries.  
 <a href="classNuria_1_1MiniLexer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="minilexer_8hpp_source.html">minilexer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Nuria::MiniLexer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classNuria_1_1MiniLexer.png" usemap="#Nuria::MiniLexer_map" alt=""/>
  <map id="Nuria::MiniLexer_map" name="Nuria::MiniLexer_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1f51b2117dfb431e3315772cf485f993"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f51b2117dfb431e3315772cf485f993"></a>
typedef QPair&lt; int, QString &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TokenValue</b></td></tr>
<tr class="separator:a1f51b2117dfb431e3315772cf485f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ccc650d3b025df8fa0075a362c7582"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52ccc650d3b025df8fa0075a362c7582"></a>
typedef QList&lt; TokenValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TokenValueList</b></td></tr>
<tr class="separator:a52ccc650d3b025df8fa0075a362c7582"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8668edb7b592c77564b97515a3e46743"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8668edb7b592c77564b97515a3e46743"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MiniLexer</b> (QObject *parent=0)</td></tr>
<tr class="separator:a8668edb7b592c77564b97515a3e46743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad760a9826197cf3028a3b99141a65f7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#ad760a9826197cf3028a3b99141a65f7c">addDefinition</a> (const QString &amp;name, const QVariantList &amp;def)</td></tr>
<tr class="separator:ad760a9826197cf3028a3b99141a65f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ce1612c9d600726894b1dec788c710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#ad4ce1612c9d600726894b1dec788c710">addRule</a> (const QString &amp;name, const QRegExp &amp;regExp, int <a class="el" href="classNuria_1_1MiniLexer.html#ac469366e31196987042cc4b443b615da">token</a>)</td></tr>
<tr class="separator:ad4ce1612c9d600726894b1dec788c710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a631325910ee71850fa4238c6a96a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#ab0a631325910ee71850fa4238c6a96a5">addRule</a> (const QString &amp;name, const QString &amp;string, int <a class="el" href="classNuria_1_1MiniLexer.html#ac469366e31196987042cc4b443b615da">token</a>)</td></tr>
<tr class="separator:ab0a631325910ee71850fa4238c6a96a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4d7c900cc562cb738d3599bc1264c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#ace4d7c900cc562cb738d3599bc1264c8">addRule</a> (const QString &amp;name, const QRegularExpression &amp;regExp, int <a class="el" href="classNuria_1_1MiniLexer.html#ac469366e31196987042cc4b443b615da">token</a>)</td></tr>
<tr class="separator:ace4d7c900cc562cb738d3599bc1264c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439827c353784af5cc852cb92c8035f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#a439827c353784af5cc852cb92c8035f1">errorPosition</a> () const </td></tr>
<tr class="separator:a439827c353784af5cc852cb92c8035f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c544b1a690b891063e919b4f81e174"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#ac5c544b1a690b891063e919b4f81e174">hasDefinition</a> (const QString &amp;name) const </td></tr>
<tr class="separator:ac5c544b1a690b891063e919b4f81e174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906c12301b9d90fb0f34837e38ca8062"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#a906c12301b9d90fb0f34837e38ca8062">hasRule</a> (const QString &amp;name) const </td></tr>
<tr class="separator:a906c12301b9d90fb0f34837e38ca8062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201dddc1c3e0d67215aebed5871cfa61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#a201dddc1c3e0d67215aebed5871cfa61">hasStartDefinition</a> () const </td></tr>
<tr class="separator:a201dddc1c3e0d67215aebed5871cfa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c00ca84a5f02e196b6ea13711aaf31d"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#a9c00ca84a5f02e196b6ea13711aaf31d">lastError</a> () const </td></tr>
<tr class="separator:a9c00ca84a5f02e196b6ea13711aaf31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7317d92211c550627847ce731002d804"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#a7317d92211c550627847ce731002d804">length</a> () const </td></tr>
<tr class="separator:a7317d92211c550627847ce731002d804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb169395fc29d7fd5e66abfac1089273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#abb169395fc29d7fd5e66abfac1089273">lex</a> (const QString &amp;data)</td></tr>
<tr class="separator:abb169395fc29d7fd5e66abfac1089273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a32a3b3c0df83a04a007abc96576c9"><td class="memItemLeft" align="right" valign="top">Qt::CaseSensitivity&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#a09a32a3b3c0df83a04a007abc96576c9">matchSensitivity</a> () const </td></tr>
<tr class="separator:a09a32a3b3c0df83a04a007abc96576c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e3061f2103f67206c78898c00d2531"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#ad2e3061f2103f67206c78898c00d2531">setMatchSensitivity</a> (Qt::CaseSensitivity <a class="el" href="classNuria_1_1MiniLexer.html#abe8923bf35d5bb29bf932cd35c870225">value</a>)</td></tr>
<tr class="separator:ad2e3061f2103f67206c78898c00d2531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac469366e31196987042cc4b443b615da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#ac469366e31196987042cc4b443b615da">token</a> (int at) const </td></tr>
<tr class="separator:ac469366e31196987042cc4b443b615da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f19faea60a1c31965f071d45171652"><td class="memItemLeft" align="right" valign="top">TokenValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#a91f19faea60a1c31965f071d45171652">tokenValue</a> (int at) const </td></tr>
<tr class="separator:a91f19faea60a1c31965f071d45171652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71c264e96c9c178122e0ef2b288f120"><td class="memItemLeft" align="right" valign="top">TokenValueList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#ad71c264e96c9c178122e0ef2b288f120">tokenValueList</a> () const </td></tr>
<tr class="separator:ad71c264e96c9c178122e0ef2b288f120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8923bf35d5bb29bf932cd35c870225"><td class="memItemLeft" align="right" valign="top">const QString &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#abe8923bf35d5bb29bf932cd35c870225">value</a> (int at) const </td></tr>
<tr class="separator:abe8923bf35d5bb29bf932cd35c870225"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a11fc279c50979ddd249f229530b80dec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNuria_1_1MiniLexer.html">MiniLexer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNuria_1_1MiniLexer.html#a11fc279c50979ddd249f229530b80dec">createInstanceFromDefinition</a> (const QString &amp;definition, QString &amp;error)</td></tr>
<tr class="separator:a11fc279c50979ddd249f229530b80dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A simple lexer. You can use this class if you want to parse some data based on regular expressions. It is not really smart, as it is meant to be used for simple tasks. NQL uses it for example to parse queries. </p>
<dl class="section warning"><dt>Warning</dt><dd>If you know Flex then be warned that the meanings of 'rules' and 'definitions' are switched in <a class="el" href="classNuria_1_1MiniLexer.html" title="A simple lexer. You can use this class if you want to parse some data based on regular expressions...">MiniLexer</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If compiled on Qt5, QRegularExpression is also supported.</dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This example assumes that you have  using namespace Nuria; somewhere in your code.</dd></dl>
<p>Lets see a little example. Lets say we want to write a INI-Parser. First, we need a <a class="el" href="classNuria_1_1MiniLexer.html" title="A simple lexer. You can use this class if you want to parse some data based on regular expressions...">MiniLexer</a> instance. We also create a enumeration of possible tokens. </p><div class="fragment"><div class="line"><span class="keyword">enum</span> IniTokens { TokenGroup, TokenKey, TokenValue };</div>
<div class="line">MiniLexer lexer;</div>
</div><!-- fragment --><p> Next we need some rules. A line in an ini file is either a group declaration or a Key=Value pair.<br />
A group looks like this: <em>[Groupname]</em><br />
A Key=Value pair looks like: <em>Key = Value</em><br />
The whitespace in front and back of the equal sign is optional. So, our first rule will take care of groups: </p><div class="fragment"><div class="line"><span class="comment">// Rule for INI groups. Accepts anything in the brackets excluding [].</span></div>
<div class="line">lexer.addRule (<span class="stringliteral">&quot;Group&quot;</span>, QRegExp (<span class="stringliteral">&quot;^\\[[^\\[\\]]+\\]$&quot;</span>), TokenGroup);</div>
</div><!-- fragment --><p> We head directly to the next two rules: </p><div class="fragment"><div class="line"><span class="comment">// Matches on anything before the first equal sign</span></div>
<div class="line">lexer.addRule (<span class="stringliteral">&quot;Key&quot;</span>, QRegExp (<span class="stringliteral">&quot;[^=]+&quot;</span>), TokenKey);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Matches on everything to the newline character</span></div>
<div class="line">lexer.addRule (<span class="stringliteral">&quot;Value&quot;</span>, QRegExp (<span class="stringliteral">&quot;[^\n]*&quot;</span>, TokenValue);</div>
</div><!-- fragment --><p> Okay, now we need to tell <a class="el" href="classNuria_1_1MiniLexer.html" title="A simple lexer. You can use this class if you want to parse some data based on regular expressions...">MiniLexer</a> how a line must look like. For this, we define two definitions. One for groups, and the other one for Key=Value pairs: </p><div class="fragment"><div class="line">lexer.addDefinition (QString(), QVariantList() &lt;&lt; QVariant::fromValue (LexerRule (<span class="stringliteral">&quot;Group&quot;</span>)));</div>
<div class="line">lexer.addDefinition (QString(), QVariantList() &lt;&lt; QVariant::fromValue (LexerRule (<span class="stringliteral">&quot;Key&quot;</span>))</div>
<div class="line">    &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; QVariant::fromValue (LexerRule (<span class="stringliteral">&quot;Value&quot;</span>)));</div>
</div><!-- fragment --><p> Next part, the lexing itself. We open up a file called "test.ini" using QFile and lex line after line, printing whatever we get. We break up if something goes wrong. </p><div class="fragment"><div class="line">QFile file (<span class="stringliteral">&quot;test.ini&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (!file.open (QIODevice::ReadOnly | QIODevice::Text)) {</div>
<div class="line">    qFatal (<span class="stringliteral">&quot;Failed to open test.ini&quot;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span> (!file.atEnd ()) {</div>
<div class="line">    <span class="keywordflow">if</span> (!lexer.lex (file.readLine ())) {</div>
<div class="line">        qFatal (<span class="stringliteral">&quot;Syntax error.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (lexer.token (0) == TokenGroup) {</div>
<div class="line">        qDebug() &lt;&lt; <span class="stringliteral">&quot;Group:&quot;</span> &lt;&lt; lexer.value (0);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        qDebug() &lt;&lt; lexer.value (0) &lt;&lt; <span class="stringliteral">&quot;-&gt;&quot;</span> &lt;&lt; lexer.value (1);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And thats it. You could also use QSettings when you want to read ini files, but wheres the fun in it if you can also use a lexer? :P </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad760a9826197cf3028a3b99141a65f7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nuria::MiniLexer::addDefinition </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantList &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a definition to the lexer. A definition declares how the input should look like (Think of it being like BNF, but using C++ stuff to describe things instead of some text input). You can do that by using strings, regular expressions, rules and other definitions in the <em>def</em> list. You can add multiple definitions to a <em>name</em>. You can't remove a definition later. <a class="el" href="classNuria_1_1MiniLexer.html" title="A simple lexer. You can use this class if you want to parse some data based on regular expressions...">MiniLexer</a> isn't really smart when it comes to matching. That being said, make sure that when a specific match order of definitions with the same <em>name</em> is important, <a class="el" href="classNuria_1_1MiniLexer.html" title="A simple lexer. You can use this class if you want to parse some data based on regular expressions...">MiniLexer</a> tries from the top which is least-important to most-important at the bottom. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="classNuria_1_1MiniLexer.html" title="A simple lexer. You can use this class if you want to parse some data based on regular expressions...">MiniLexer</a> uses "" as start definition. To add a start definition simply pass <code>QString()</code> as <em>name</em>. </dd>
<dd>
To put a reference to a rule into the list, use: QVariant::fromValue(<a class="el" href="classNuria_1_1LexerRule.html">LexerRule</a>("Name of the rule")) </dd>
<dd>
Same goes for references to definitions: QVariant::fromValue(<a class="el" href="classNuria_1_1LexerDefinition.html">LexerDefinition</a>("Name of the definition")) </dd></dl>

</div>
</div>
<a class="anchor" id="ad4ce1612c9d600726894b1dec788c710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nuria::MiniLexer::addRule </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QRegExp &amp;&#160;</td>
          <td class="paramname"><em>regExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a rule to the lexer. <em>name</em> must be unique (if there is already a rule with the same name, it will be overwritten). <em>regExp</em> is the regular expressions which is connected to this rule. <em>token</em> is a user-defined token id which is used to distinguish between different rules after the lexer has been run. </p><dl class="section note"><dt>Note</dt><dd>When you pass <code>-1</code> as <em>token</em>, matches for this rule won't be stored for later use. </dd>
<dd>
If you only care about a certain part of the match, then capture it using (brackets). <a class="el" href="classNuria_1_1MiniLexer.html" title="A simple lexer. You can use this class if you want to parse some data based on regular expressions...">MiniLexer</a> will take the first captured text as value if it finds any. Else, it takes the whole match as value. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0a631325910ee71850fa4238c6a96a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nuria::MiniLexer::addRule </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ace4d7c900cc562cb738d3599bc1264c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nuria::MiniLexer::addRule </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QRegularExpression &amp;&#160;</td>
          <td class="paramname"><em>regExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a11fc279c50979ddd249f229530b80dec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNuria_1_1MiniLexer.html">MiniLexer</a>* Nuria::MiniLexer::createInstanceFromDefinition </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>definition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classNuria_1_1MiniLexer.html" title="A simple lexer. You can use this class if you want to parse some data based on regular expressions...">MiniLexer</a> instance based on a definition string. If parsing failed, the <a class="el" href="classNuria_1_1MiniLexer.html#a201dddc1c3e0d67215aebed5871cfa61">hasStartDefinition()</a> method of the returned <a class="el" href="classNuria_1_1MiniLexer.html" title="A simple lexer. You can use this class if you want to parse some data based on regular expressions...">MiniLexer</a> instance will return <em>false</em>. <em>error</em> will contain a human-readable error message.<br />
<em>definition</em> must be a string with the following format: </p><ul>
<li>
<code>#</code> Starts a comment. It ends at the end of the line. It can only appear at the beginning of a line </li>
<li>
<p class="startli"><code>Rule</code>(<code><a class="el" href="structNuria_1_1Token.html" title="Token as returned by Nuria::Tokenizer. ">Token</a></code> ): <code>Body</code> </p><ul>
<li>
<code>Rule</code> = The name of the rule. May be prefixed with a $ </li>
<li>
<code><a class="el" href="structNuria_1_1Token.html" title="Token as returned by Nuria::Tokenizer. ">Token</a></code> = The token id as integer </li>
<li>
<code>Body</code> = The rule body. May be a "string" or a /regex/ </li>
</ul>
<p class="endli"></p>
</li>
<li>
<code>Definiton</code> = <code>Body</code> ; <ul>
<li>
<code>Definition</code> = The name of the definition. Must not be prefixed with a $ </li>
<li>
<code>Body</code> = The body of the definition. The body contains one or more items separated with whitespace. The body ends with a semicolon ';'. Possible items are: <ul>
<li>
A C-style string literal enclosed in "" </li>
<li>
A regular expression enclosed in // (Slashes). A single 'i' after the closing slash marks the regular expression to match case-insensitive. </li>
<li>
A name of a definition. Just write the name itself. </li>
<li>
A name of a rule. Prefix the name with a dollar-sign '$' </li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>You can format the definition string using different types of whitespace. The method is pretty free in that regard. </dd>
<dd>
Also read the docs of addRule and addDefinition. They also apply on this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a439827c353784af5cc852cb92c8035f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Nuria::MiniLexer::errorPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If lex fails, this function will return the position where the error occured. </p>

</div>
</div>
<a class="anchor" id="ac5c544b1a690b891063e919b4f81e174"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Nuria::MiniLexer::hasDefinition </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <em>true</em> if there is a definition with the name <em>name</em>. </p>

</div>
</div>
<a class="anchor" id="a906c12301b9d90fb0f34837e38ca8062"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Nuria::MiniLexer::hasRule </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <em>true</em> if there is a rule with the name <em>name</em>. </p>

</div>
</div>
<a class="anchor" id="a201dddc1c3e0d67215aebed5871cfa61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Nuria::MiniLexer::hasStartDefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <em>true</em> if this instance has a start definition (e.g. a definition with the name ""). </p>

</div>
</div>
<a class="anchor" id="a9c00ca84a5f02e196b6ea13711aaf31d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString Nuria::MiniLexer::lastError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If lex fails, this function will return a human-readable string describing the problem. </p>

</div>
</div>
<a class="anchor" id="a7317d92211c550627847ce731002d804"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Nuria::MiniLexer::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the count of parsed tokens. </p>

</div>
</div>
<a class="anchor" id="abb169395fc29d7fd5e66abfac1089273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Nuria::MiniLexer::lex </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lexes <em>data</em>. Returns <em>true</em> if <em>data</em> could be completely parsed, returns <em>false</em> otherwise. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classNuria_1_1MiniLexer.html#ad71c264e96c9c178122e0ef2b288f120">tokenValueList</a> <a class="el" href="classNuria_1_1MiniLexer.html#a91f19faea60a1c31965f071d45171652">tokenValue</a> <a class="el" href="classNuria_1_1MiniLexer.html#ac469366e31196987042cc4b443b615da">token</a> <a class="el" href="classNuria_1_1MiniLexer.html#abe8923bf35d5bb29bf932cd35c870225">value</a> <a class="el" href="classNuria_1_1MiniLexer.html#a9c00ca84a5f02e196b6ea13711aaf31d">lastError</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a09a32a3b3c0df83a04a007abc96576c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Qt::CaseSensitivity Nuria::MiniLexer::matchSensitivity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if strings are matched case-sensitive or case-insensitive. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classNuria_1_1MiniLexer.html#ad2e3061f2103f67206c78898c00d2531">setMatchSensitivity</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad2e3061f2103f67206c78898c00d2531"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nuria::MiniLexer::setMatchSensitivity </td>
          <td>(</td>
          <td class="paramtype">Qt::CaseSensitivity&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets if strings should be matched case-sensitive or case-insensitive. This only applies to strings and has no effect on regular expressions. Default is case-sensitive matching. </p>

</div>
</div>
<a class="anchor" id="ac469366e31196987042cc4b443b615da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Nuria::MiniLexer::token </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>at</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the token of a token/value pair at position <em>at</em>. </p>

</div>
</div>
<a class="anchor" id="a91f19faea60a1c31965f071d45171652"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TokenValue Nuria::MiniLexer::tokenValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>at</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a single TokenValue pair. TokenValue is a typedef for <code>QPair&lt;int,QString&gt;</code>. <em>first</em> is the token id, <em>second</em> the value. </p>

</div>
</div>
<a class="anchor" id="ad71c264e96c9c178122e0ef2b288f120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TokenValueList Nuria::MiniLexer::tokenValueList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of TokenValue's containing the current list of token and values. </p>

</div>
</div>
<a class="anchor" id="abe8923bf35d5bb29bf932cd35c870225"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QString&amp; Nuria::MiniLexer::value </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>at</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of a token/value pair at position <em>at</em>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="minilexer_8hpp_source.html">minilexer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Sep 2 2014 23:28:10 for NuriaProject Framework by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
